()の中の要素を,で区切ってtypeで確認するとtuple型になる

要素が一つでも後ろに,をつけることでtuple型になる
→,を忘れて一つだけ文字列などを入れているとただの文字列型になってしまう。

tupleの連結は+で行う。

tupleのインデックス番号をとってくるときは[]を使う。

tupleの上書き、削除、追加はできない
→インデックス番号を指定して取り出すことはできるが代入して上書きすることができない
→TypeErrorになる。(SyntaxErrorにはならないことも注意)

tuple(〇)→〇をtupleにする
→〇には数字でも文字列でも入れることができる
→〇にlist型を入れるとtupleにすることができる
→〇を空にすると空のtupleができる
→変数 = ()でも空のtupleが作れる

tuple型のデータをlist()関数の中に入れるとlist型にすることができる

()に入れなくても複数の要素を,で区切って代入するとtupleになる
→()を省略できる

tupleをtupleに代入するとそれぞれ要素が代入される

タプルのアンパックを使うと交換作業が簡単になる
→退避領域を作って移動的なことがなくなる

タプルにしたものをそのまま振り分けて代入することができる
→変数に代入されたタプルでも可能

print(調べたいもの in タプルデータ)→タプルデータに調べたいものが含まれているかを調べる。

タプルのオブジェクトは別々で作ると本来Falseになるのだが、Trueを返してしまうこともある
→Pythonの最適化

リストをtuple()でtuple型にしたあとに比較をすればPythonの最適化を無視して正しい比較ができる

zip()でつくられたオブジェクトを基本zip_objという
→中身はみれない。zip型

イテレーター→複数の値を一つでまとめてくれるもの

zip objectで一回使った中身は空になる
→再利用できない

(応用)
tuple型ではデータの変換ができない→list型にして変換する

集合は波かっこ{}で表す

集合同士を足し合わせるために+は使えない

集合同士を足し合わせるには|を使う

足し合わせた要素の中に同じ要素があったら自動的に一つにされる

len()を使うと集合の要素の数を取得できる

要素 in 集合→要素が集合に含まれているかどうか調べる。True or False

inの前にnotをつけることで否定になる

空のセットを作るときに{}の中身を空にして作ってもdict型(辞書型)になってしまう
→set()を使うことで空のセットを作ることでset型にできる

空集合を作りたい→set()
空辞書を作りたい→{}

set(〇)→〇をsetにする

値が一つでも入っていればset型になる

setにはインデックス番号という概念がない
→インデックス番号を指定して取り出そうとするとエラーになる
→自分の思った順番で出てくることがない

セットから文字列に直すことは一応できるが、並び方もばらばらで、重複して消えていった文字も戻ってこないので、元の文字列に戻すことは難しい
→戻すには"".join()を使う